# 解释器模式

## 意图

给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。

**解决：**对于一些固定文法构建一个解释句子的解释器。



## 适用性

**应用实例：**编译器、运算表达式计算。

1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树；

2、一些重复出现的问题可以用一种简单的语言来进行表达；

3、一个简单语法需要解释的场景；



## 类图

![解释器模式的结构图](.pics/interpret/interpret.png)

- **抽象表达式**（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。
- **终结符表达式**（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。
- **非终结符表达式**（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。
- **环境**（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。
- **客户端**（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。

## 优缺点

**优点：** 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。

**缺点：** 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。



## 实现

### ~~fel（2013 0.8）~~

### ~~expression4j（非生产商用）~~

### Java expression parser

Jep是一个用来转换和计算数学表达式的java库，支持用户自定义变量、常量和函数。

### Groovy